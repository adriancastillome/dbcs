# Oracle 20c Blockchain Tables Preview

## Introduction

Blockchain tables are append-only tables in which only insert operations are allowed. Deleting rows is either prohibited or restricted based on time. Rows in a blockchain table are made tamper-resistant by special sequencing & chaining algorithms. Users can verify that rows have not been tampered. A hash value that is part of the row metadata is used to chain and validate rows.

Blockchain tables enable you to implement a centralized ledger model where all participants in the blockchain network have access to the same tamper-resistant ledger.

A centralized ledger model reduces administrative overheads of setting a up a decentralized ledger network, leads to a relatively lower latency compared to decentralized ledgers, enhances developer productivity, reduces the time to market, and leads to significant savings for the organization. Database users can continue to use the same tools and practices that they would use for other database application development.

## Step 1: Genera

Under Bare Metal, VM, and Exadata, Create DB System. It has to be Virtual Machine, and use Logical Volume Manager. On the second page of the wizard you will be able to select Database Version 20c Preview. All these commands are executed via SQL*Plus, connected via SSH to my DB System, with Hostname Prefix dbsys20c. Blockchain tables cannot be created in the root container and in an application root container, so I will use a pluggable database called PDB01.

````
sqlplus system/MyDBsysPass@dbsys20c:1521/pdb01.sub01020304050.myvcn.oraclevcn.com
````

Database users require no special privileges to create and work with blockchain tables or JSON data type. A simple user will do the job just fine. As a best practice, you can create a specific tablespace for storing JSON documents, but for this simple case we will use the existing one.

````
SQL> create user ooe identified by "MyDBsysPass" default tablespace USERS quota unlimited on USERS;
````

````
SQL> GRANT connect, resource to ooe;
````

The rest of the scenario is executed by OOE user we just created.

````
SQL> conn ooe/MyDBsysPass@dbsys20c:1521/pdb01.sub01020304050.myvcn.oraclevcn.com
````

Some formatting for SQL*Plus will help me understand the output better. Hit Enter one more time after pasting these lines.

````
SQL> set linesize 130
set serveroutput on
set pages 9999
set long 90000
column table_name format a40
column order_doc format a40
column name format a40
column shipTo format a40
````

Let's say we got bored of the old fashion relational table orders. We can create a new orders table, that is smart, secure, and cool at the same time. This table uses the new identity column type for the primary key (new in 12c), native JSON data type that allows our application to make changes in the order document at any time (e.g. adding new fields, separating billing from shipping addresses, etc.), and a special sequencing & algorithm (SHA-2 512-bit cryptographic hash) used to chain and validate rows making it tamper-resistant.

- `NO DROP` is used to specify the retention period for the table after no new inserts;
- `NO DELETE` is used to set the retention period for rows;
- `HASHING USING`, and `VERSION` clauses are mandatory in a `CREATE BLOCKCHAIN TABLE` statement. 

In our case, orders blockchain table cannot be dropped if the newest row is less than 60 days old, and rows cannot be deleted until 16 days after the most recent row was added.

````
SQL> CREATE BLOCKCHAIN TABLE orders
( order_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY
    MINVALUE 1 MAXVALUE 9999999999999999999999999999
    INCREMENT BY 1 START WITH 1 CACHE 20 NOT NULL ENABLE,
  order_doc JSON,
  created DATE,
  created_by VARCHAR2(20),
  currency VARCHAR2(3),
  channel VARCHAR2(20),
  CONSTRAINT orders_pk PRIMARY KEY (order_id)
    USING INDEX ENABLE
)
NO DROP UNTIL 60 DAYS IDLE
NO DELETE UNTIL 16 DAYS AFTER INSERT
HASHING USING "SHA2_512" VERSION "v1";
````

On top of that, this table saves the date when each order is created, and the database user that created that order.

````
SQL> CREATE OR REPLACE EDITIONABLE TRIGGER orders_bi
    before insert on orders
    for each row
begin
    :new.created := SYSDATE;
    :new.created_by := SYS_CONTEXT('USERENV','SESSION_USER');
    if :new.currency is null then
        :new.currency := 'USD';
    end if;
end;
/
````

````
SQL> ALTER TRIGGER orders_bi ENABLE;
````


Describe the blockchain tables owned by the current OOE user with this query.

````
SQL> SELECT * FROM USER_BLOCKCHAIN_TABLES;

TABLE_NAME       ROW_RETENTION ROW TABLE_INACTIVITY_RETENTION HASH_ALG
---------------- ------------- --- -------------------------- --------
ORDERS                      16 NO                          60 SHA2_512
````

We can modify, more exactly increase, the retention period for a blockchain table and for rows within a blockchain table, but never decrease. Modify the definition of orders blockchain table so rows cannot be deleted until 31 days after they were created. By adding a `LOCKED` clause we indicate that this setting can never be modified.

````
SQL> ALTER TABLE orders NO DELETE UNTIL 31 DAYS AFTER INSERT LOCKED;
````

````
SQL> SELECT * FROM USER_BLOCKCHAIN_TABLES;

TABLE_NAME       ROW_RETENTION ROW TABLE_INACTIVITY_RETENTION HASH_ALG
---------------- ------------- --- -------------------------- --------
ORDERS                      31 YES                         60 SHA2_512
````

JSON native data type automatically validates the format, and does not require a IS JSON check constraint like in previous Oracle versions.

````
SQL> INSERT INTO orders (order_doc) VALUES ('++{} "This is not a valid", "JSON" ::; "document !"');

ORA-40441: JSON syntax error
````

Insert some valid rows into the table.

````
SQL> INSERT INTO orders (order_doc, currency) VALUES (
'{ "name"  : "Joe Bravo",
  "sku"    : "5",
  "price"  : 23.95,
  "shipTo" : { "name" : "Eva Bravo",
              "address" : "Via Calimala, 23",
              "city" : "Firenze",
              "country" : "IT",
              "zip"  : "50123" },
  "billTo" : { "name" : "Joe Bravo",
              "address" : "Via Calimala, 23",
              "city" : "Firenze",
              "country" : "IT",
              "zip"  : "50123" }
}',
'EUR');
````

````
SQL> INSERT INTO orders (order_doc, channel) VALUES (
'{ "name"  : "Carmen Flores",
  "sku"    : "8",
  "price"  : 199.95,
  "shipTo" : { "name" : "Mario Flores",
              "address" : "Gran Via, 25",
              "city" : "Salamanca",
              "country" : "ES",
              "zip"  : "37001" },
  "billTo" : { "name" : "Carmen Flores",
              "address" : "Gran Via, 25",
              "city" : "Salamanca",
              "country" : "ES",
              "zip"  : "37001" }
}',
'online');
````

JSON documents can be inserted in any shape as long as we keep the structure, we don't have to use a clear human readable shape.

````
SQL> INSERT INTO orders (order_doc, currency, channel) VALUES ('{ "name" : "Francis Picard", "sku" : "10", "price" : 65.95, "shipTo" : { "name" : "Maria Picard", "address" : "25 Avenue Jean Jaures", "city" : "Lyon", "country" : "FR", "zip"  : "69007" }, "billTo" : { "name" : "Francis Picard", "address" : "25 Avenue Jean Jaures", "city" : "Lyon", "country" : "FR", "zip"  : "69007" }}', 'EUR', 'direct');
````

````
SQL> COMMIT;
````

As you can see, all JSON documents in the orders table have the same shape, even though we inserted the first two in a clear format, and the last one as a continuous string.

````
SQL> SELECT * FROM orders;

  ORDER_ID ORDER_DOC                                CREATED   CREATED_BY           CUR CHANNEL
---------- ---------------------------------------- --------- -------------------- --- --------------------
         2 {"name":"Joe Bravo","sku":"5","price":23 04-JUN-20 OOE                  EUR
           .95,"shipTo":{"name":"Eva Bravo","addres
           s":"Via Calimala, 23","city":"Firenze","
           country":"IT","zip":"50123"},"billTo":{"
           name":"Joe Bravo","address":"Via Calimal
           a, 23","city":"Firenze","country":"IT","
           zip":"50123"}}

         3 {"name":"Carmen Flores","sku":"8","price 04-JUN-20 OOE                  USD online
           ":199.95,"shipTo":{"name":"Mario Flores"
           ,"address":"Gran Via, 25","city":"Salama
           nca","country":"ES","zip":"37001"},"bill
           To":{"name":"Carmen Flores","address":"G
           ran Via, 25","city":"Salamanca","country
           ":"ES","zip":"37001"}}

         4 {"name":"Francis Picard","sku":"10","pri 04-JUN-20 OOE                  EUR direct
           ce":65.95,"shipTo":{"name":"Maria Picard
           ","address":"25 Avenue Jean Jaures","cit
           y":"Lyon","country":"FR","zip":"69007"},
           "billTo":{"name":"Francis Picard","addre
           ss":"25 Avenue Jean Jaures","city":"Lyon
           ","country":"FR","zip":"69007"}}
````

There are ways of retrieving the information in a clear human readable format.

````
SQL> SELECT o.order_id,
      JSON_SERIALIZE(o.order_doc PRETTY) order_doc,
      to_char(created, 'HH24:MM:SS DD-MON-YY') created
FROM orders o;

  ORDER_ID ORDER_DOC                                CREATED
---------- ---------------------------------------- ---------------------------
         2 {                                        18:06:48 04-JUN-20
             "name" : "Joe Bravo",
             "sku" : "5",   
             "price" : 23.95,
             "shipTo" :
             {
               "name" : "Eva Bravo",
               "address" : "Via Calimala, 23",
               "city" : "Firenze",
               "country" : "IT",
               "zip" : "50123"
             },
             "billTo" :
             {
               "name" : "Joe Bravo",
               "address" : "Via Calimala, 23",
               "city" : "Firenze",
               "country" : "IT",
               "zip" : "50123"
             }
           }

          3 {                                        18:06:59 04-JUN-20
             "name" : "Carmen Flores",
             "sku" : "8",
             "price" : 199.95,
             "shipTo" :
             {
               "name" : "Mario Flores",
               "address" : "Gran Via, 25",
               "city" : "Salamanca",
               "country" : "ES",
               "zip" : "37001"
              },
             "billTo" :
             {
               "name" : "Carmen Flores",
               "address" : "Gran Via, 25",
               "city" : "Salamanca",
               "country" : "ES",
               "zip" : "37001"
             }
           }

         4 {                                        18:06:11 04-JUN-20
             "name" : "Francis Picard",
             "sku" : "10",
              "price" : 65.95,
              "shipTo" :
             {
               "name" : "Maria Picard",
               "address" : "25 Avenue Jean Jaures",
               "city" : "Lyon",
                "country" : "FR",
               "zip" : "69007"
             },
             "billTo" :
             {
               "name" : "Francis Picard",
               "address" : "25 Avenue Jean Jaures",
               "city" : "Lyon",
               "country" : "FR",
               "zip" : "69007"
             }
           }
````

We can even retrieve individual fields from the orders stored as JSON documents.

````
SQL> SELECT o.order_id, o.order_doc."name", o.order_doc."shipTo"."address" FROM orders o;

  ORDER_ID name                                     shipTo
---------- ---------------------------------------- -------------------------------
         2 "Joe Bravo"                              "Via Calimala, 23"
         3 "Carmen Flores"                          "Gran Via, 25"
         4 "Francis Picard"                         "25 Avenue Jean Jaures"
````

However, we cannot update rows, delete rows, truncate or drop the blockchain table. We cannot even drop the tablespace containing a blockchain table (go ahead and try it, but connecting with SYSDBA privileges).

````
SQL> DELETE FROM orders WHERE order_id > 2;

ORA-05715: operation not allowed on the blockchain table
````

````
SQL> TRUNCATE TABLE orders;

ORA-05715: operation not allowed on the blockchain table
````

````
SQL> UPDATE orders SET currency = 'GBP' WHERE order_id > 2;

ORA-05715: operation not allowed on the blockchain table
````

````
SQL> DROP TABLE orders;

ORA-05723: drop blockchain table ORDERS not allowed
````

For management purposes it is important to understand the hidden columns in blockchain tables. Here are a few of them: 

- `ORABCTAB_INST_ID$` is the database instance ID;
- `ORABCTAB_CHAIN_ID$` represents the ID of the chain with values between 0 and 31;
- `ORABCTAB_USER_NUMBER$` is the ID of the database user who inserted the row;
- `ORABCTAB_HASH$` contains the hash value of the row computed based on current row content and hash value of the previous row.

````
SQL> SELECT o.order_id, o.order_doc."name", ORABCTAB_INST_ID$, ORABCTAB_CHAIN_ID$, ORABCTAB_USER_NUMBER$, ORABCTAB_HASH$ FROM orders o;

  ORDER_ID name                                     ORABCTAB_INST_ID$ ORABCTAB_CHAIN_ID$ ORABCTAB_USER_NUMBER$
---------- ---------------------------------------- ----------------- ------------------ ---------------------
ORABCTAB_HASH$
----------------------------------------------------------------------------------------------------------------------------------
         2 "Joe Bravo"                              1                 12                 113
ACC12150F672BA9E5491EADE2C290BA2EB4AD23B3F13D2C919015B0D2633CCCAC035241ED4019329DC445969B0B8488704F2A7DD08C090C0A454A1252E458553
         3 "Carmen Flores"                          1                 12                 113
93F697F51245F7AD4778328D891F04F1432896B244B915A803AFBD9178BDA6388AC1792CB2B64C631F11D419AB64620A40CB3D470CD54926BAD85B554A55BB03
         4 "Francis Picard"                         1                 12                 113
9018522AFA8E50A3CB477FD110F333F18EBBB1B46733E472ADCC8429D4170A3D6E3607B70722764C63B1E9D93876079EC718D5A064CCF91670CC9609EDB8DE36
````

It is easy to verify `ORABCTAB_USER_NUMBER$` for example.

````
SQL> select SYS_CONTEXT('USERENV','SESSION_USERID') from dual;

SYS_CONTEXT('USERENV','SESSION_USERID')
-----------------------------------------------------------------------
113
````

Last but not least, I want to mention the `DBMS_BLOCKCHAIN_TABLE` package that can be used to manage records in blockchain tables. Some of the tasks we can perform are: delete rows that are beyond the retention period, sign a row you inserted after it is added to a chain, or verify the hashes and signatures on rows. Here is a simple example of verifying or validating a row.

````
SQL> DECLARE
      verify_rows NUMBER;
      instance_id NUMBER;
BEGIN
      instance_id := 1;
      DBMS_BLOCKCHAIN_TABLE.VERIFY_ROWS('OOE','ORDERS', NULL, NULL, instance_id, NULL, verify_rows);
      DBMS_OUTPUT.PUT_LINE(' Number of rows verified in instance Id '|| instance_id || ' = '|| verify_rows);
END;
/

>>> Number of rows verified in instance Id 1 = 3
````

This is .

## Acknowledgements

- **Author** - Valentin Leonard Tabacaru
- **Last Updated By/Date** - Valentin Leonard Tabacaru, Principal Product Manager, DB Product Management, Aug 2020

See an issue? Please open up a request [here](https://github.com/oracle/learning-library/issues). Please include the workshop name and lab in your request.

